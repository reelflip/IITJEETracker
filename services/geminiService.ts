
import { PlanRequest, Question, TimetableConstraints, Subject, Difficulty, WeeklySchedule, DailySchedule } from "../types";
import { MOCK_QUESTION_DB } from "../constants";

// Helper to simulate "processing" time for a realistic feel
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// --- Time Helper Functions ---

const timeToMins = (time: string): number => {
  if (!time) return 0;
  const [h, m] = time.split(':').map(Number);
  return h * 60 + m;
};

const minsToTime = (mins: number): string => {
  let h = Math.floor(mins / 60);
  const m = mins % 60;
  if (h >= 24) h -= 24;
  if (h < 0) h += 24; // Handle negative wrapping
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
};

const formatTimeRange = (start: number, end: number): string => {
  return `${minsToTime(start)} - ${minsToTime(end)}`;
};

// --- Timeline Engine Types ---

interface TimelineBlock {
  start: number;
  end: number;
  activity: string;
  type: 'fixed' | 'filler';
  category: 'coaching' | 'school' | 'study' | 'bio' | 'transit';
}

// -----------------------------

/**
 * Offline Study Plan Generator
 * Creates a deterministic plan based on inputs without AI.
 */
export const generateStudyPlan = async (request: PlanRequest): Promise<string> => {
  await delay(800); // Simulate "Thinking"
  const { topics, daysAvailable, hoursPerDay, focusArea } = request;

  let planMarkdown = `## üìÖ ${daysAvailable}-Day Action Plan\n`;
  planMarkdown += `**Focus:** ${focusArea} | **Daily Commitment:** ${hoursPerDay} Hours\n\n`;
  planMarkdown += `This plan is designed to optimize your preparation for JEE using spaced repetition and active recall.\n`;
  planMarkdown += `---\n\n`;

  const topicsList = [...topics];
  let topicIndex = 0;

  for (let day = 1; day <= daysAvailable; day++) {
    planMarkdown += `### Day ${day}\n`;
    
    // Assign topics cyclically
    const topicsForToday = [];
    if (topicsList.length > 0) {
      // Pick 1 primary topic
      topicsForToday.push(topicsList[topicIndex]);
      topicIndex = (topicIndex + 1) % topicsList.length;
    }
    
    const primaryTopic = topicsForToday[0] || "Revision of backlog";
    const slotDuration = Math.floor(hoursPerDay / 2);

    if (focusArea === "Theory Intensive") {
        planMarkdown += `- **Session 1 (${slotDuration}h):** üìñ **Theory Deep Dive** - ${primaryTopic}. Read NCERT and class notes. Focus on derivations.\n`;
        planMarkdown += `- **Session 2 (${hoursPerDay - slotDuration}h):** ‚úçÔ∏è **Short Notes** - Create formula sheets for ${primaryTopic} and solve basic illustrations.\n`;
    } else if (focusArea === "Problem Solving") {
        planMarkdown += `- **Session 1 (${slotDuration}h):** üß© **Guided Practice** - Solve 20-30 Mains level questions on ${primaryTopic}.\n`;
        planMarkdown += `- **Session 2 (${hoursPerDay - slotDuration}h):** üöÄ **Challenge Mode** - Attempt 10 Advanced level problems or PYQs for ${primaryTopic}.\n`;
    } else if (focusArea === "Revision & Mock Tests") {
        planMarkdown += `- **Session 1:** üìù **Topic Test** - Take a timed test on ${primaryTopic}.\n`;
        planMarkdown += `- **Session 2:** üîç **Analysis** - Analyze errors and revise weak concepts.\n`;
    } else {
        // Balanced
        planMarkdown += `- **Session 1 (${slotDuration}h):** üìñ **Concept Review** - Quick theory recap of ${primaryTopic}.\n`;
        planMarkdown += `- **Session 2 (${hoursPerDay - slotDuration}h):** ‚úèÔ∏è **Problem Practice** - Solve Exercise 1 & 2 for ${primaryTopic}.\n`;
    }
    
    planMarkdown += `\n`;
  }
  
  planMarkdown += `\n---\n*Generated by BT PrepTracker Smart Engine*`;
  return planMarkdown;
};

/**
 * Offline Question Generator
 * Fetches from a local DB or generates templated questions.
 */
export const generatePracticeQuestions = async (topicName: string, difficulty: string, subject?: Subject): Promise<Question[]> => {
  await delay(600);
  
  // Robust subject detection
  let derivedSubject = subject;
  if (!derivedSubject) {
      if (['Kinematics', 'Newton', 'Work', 'Rotation', 'Gravitation', 'Electrostatics', 'Current', 'Optics', 'Units'].some(k => topicName.includes(k))) derivedSubject = Subject.PHYSICS;
      else if (['Mole', 'Atomic', 'Bonding', 'Gaseous', 'Equilibrium', 'Organic', 'GOC', 'Isomerism', 'Block'].some(k => topicName.includes(k))) derivedSubject = Subject.CHEMISTRY;
      else derivedSubject = Subject.MATHS;
  }

  const dbQuestions = (derivedSubject ? MOCK_QUESTION_DB[derivedSubject] : []) || [];
  
  const results: Question[] = [];

  // 1. Add real questions from DB if available
  dbQuestions.forEach(q => {
     if (q.questionText && q.options && q.correctAnswer && q.explanation) {
       results.push({
         ...q as Question,
         difficulty: difficulty // Override for display consistency
       });
     }
  });

  // 2. Fill remaining with templated questions
  while (results.length < 5) {
    const num = results.length + 1;
    results.push({
      questionText: `[${topicName}] Conceptual Question #${num}: Which of the following statements is true regarding this topic at a ${difficulty.split(' ')[0]} level?`,
      options: [
        `Option A: Statement regarding concept 1 of ${topicName}`,
        `Option B: Statement regarding concept 2 of ${topicName}`,
        `Option C: Statement regarding concept 3 of ${topicName}`,
        `Option D: Statement regarding concept 4 of ${topicName}`
      ],
      correctAnswer: `Option A: Statement regarding concept 1 of ${topicName}`,
      explanation: `**Analysis:**\nThis is a generated practice question. In a real exam scenario, you would analyze the specific conditions given. Since the difficulty is **${difficulty}**, ensure you check for edge cases in ${topicName}.`,
      difficulty: difficulty
    });
  }

  return results.slice(0, 5);
}

/**
 * Offline Timetable Generator
 * Uses a robust Event-Timeline system to fill gaps and resolve overlaps.
 */
export const generateWeeklyTimetable = async (constraints: TimetableConstraints): Promise<WeeklySchedule> => {
  await delay(500);
  const { coachingDays, coachingTime, schoolDetails, sleepSchedule } = constraints;
  
  const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
  const subjects = ['Physics', 'Maths', 'Chemistry']; 
  let subjectIndex = 0; 

  const schedule: DailySchedule[] = [];

  // 1. Parse all constraints into minutes
  const wakeMins = timeToMins(sleepSchedule.wake);
  const bedMins = timeToMins(sleepSchedule.bed);
  const coachingStartMins = timeToMins(coachingTime.start);
  const coachingEndMins = timeToMins(coachingTime.end);
  const schoolStartMins = timeToMins(schoolDetails.start);
  const schoolEndMins = timeToMins(schoolDetails.end);

  // Determine global properties
  const coachingDuration = coachingEndMins > coachingStartMins ? coachingEndMins - coachingStartMins : (coachingEndMins + 1440) - coachingStartMins;
  
  days.forEach(day => {
    const isCoaching = coachingDays.includes(day);
    const isSchool = schoolDetails.attending && day !== 'Sun';
    const isSunday = day === 'Sun';
    
    // --- TIMELINE BUILDER ---
    let blocks: TimelineBlock[] = [];

    // Add Fixed Blocks
    if (isSchool) {
      blocks.push({
        start: schoolStartMins,
        end: schoolEndMins,
        activity: 'üè´ **School**',
        type: 'fixed',
        category: 'school'
      });
    }

    if (isCoaching) {
      blocks.push({
        start: coachingStartMins,
        end: coachingStartMins + coachingDuration,
        activity: 'üè¢ **Coaching Classes**',
        type: 'fixed',
        category: 'coaching'
      });
    }

    // Sort blocks by start time
    blocks.sort((a, b) => a.start - b.start);

    // Resolve Overlaps (Priority: Coaching > School)
    const resolvedBlocks: TimelineBlock[] = [];
    if (blocks.length > 0) {
      let current = blocks[0];
      for (let i = 1; i < blocks.length; i++) {
        const next = blocks[i];
        
        // Check overlap
        if (current.end > next.start) {
           // Conflict!
           if (current.category === 'school' && next.category === 'coaching') {
              // Trim school to end before coaching (minus travel time)
              current.end = Math.max(current.start, next.start - 30);
              // If school became 0 length or inverted, discard it? 
              // For now, keep it if duration > 0
              if (current.end > current.start) resolvedBlocks.push(current);
              current = next;
           } else if (current.category === 'coaching' && next.category === 'school') {
              // Skip school starts inside coaching
              // Or trim start of school? Usually implies skip school.
              // We just keep current (Coaching) and ignore conflicting school part
              // Logic: coaching wins.
           } else {
              resolvedBlocks.push(current);
              current = next;
           }
        } else {
          resolvedBlocks.push(current);
          current = next;
        }
      }
      resolvedBlocks.push(current);
    }
    blocks = resolvedBlocks;

    // --- GAP FILLER ---
    const finalTimeline: TimelineBlock[] = [];
    let currentTime = wakeMins;

    // Add "Wake Up"
    finalTimeline.push({ start: currentTime, end: currentTime + 30, activity: 'üåÖ Wake Up & Freshen Up', type: 'filler', category: 'bio' });
    currentTime += 30;

    // Fill gaps between current time and next fixed block
    for (const block of blocks) {
       // If gap exists
       if (block.start > currentTime) {
         const gap = block.start - currentTime;
         
         // Logic for filling gaps based on duration and context
         if (gap <= 45) {
            finalTimeline.push({ start: currentTime, end: block.start, activity: 'ü•õ Breakfast / Transit / Quick Revision', type: 'filler', category: 'transit' });
         } else if (gap < 120) {
            // Short Study or Meal
            if (currentTime < 720) { // Morning
               const sub = subjects[subjectIndex % 3];
               finalTimeline.push({ start: currentTime, end: block.start, activity: `üöÄ **Morning Boost** - ${sub} (Short Session)`, type: 'filler', category: 'study' });
            } else {
               finalTimeline.push({ start: currentTime, end: block.start, activity: 'ü•ó Lunch & Power Nap', type: 'filler', category: 'bio' });
            }
         } else {
            // Long Gap (> 2 hours) -> Deep Work
            // Check context
            if (block.category === 'coaching') {
               // Gap BEFORE coaching
               const studyTime = gap - 30; // Leave 30m for pre-class
               finalTimeline.push({ start: currentTime, end: currentTime + studyTime, activity: `üöÄ **Deep Work** - ${subjects[subjectIndex % 3]}`, type: 'filler', category: 'study' });
               finalTimeline.push({ start: currentTime + studyTime, end: block.start, activity: 'üéí Pre-class Review (Last notes)', type: 'filler', category: 'study' });
            } else {
               // Generic Gap
               const sub = subjects[subjectIndex % 3];
               finalTimeline.push({ start: currentTime, end: block.start, activity: `‚úèÔ∏è **Problem Solving** - ${sub}`, type: 'filler', category: 'study' });
            }
         }
       }
       
       // Add the fixed block itself
       finalTimeline.push(block);
       currentTime = block.end;
    }

    // Fill remaining time until bed
    if (currentTime < bedMins) {
       const gap = bedMins - currentTime;
       const lastBlock = blocks[blocks.length - 1]; // What did we just finish?

       if (lastBlock && lastBlock.category === 'coaching') {
          // POST COACHING LOGIC
          finalTimeline.push({ start: currentTime, end: currentTime + 45, activity: 'üç≤ Dinner & Relax', type: 'filler', category: 'bio' });
          currentTime += 45;
          const remaining = bedMins - currentTime;
          if (remaining > 0) {
            finalTimeline.push({ start: currentTime, end: bedMins, activity: 'üîÑ **Priority**: Revise Today\'s Class Notes & HW', type: 'filler', category: 'study' });
          }
       } else {
          // Normal Evening
          if (gap > 180) { // 3+ hours left
             finalTimeline.push({ start: currentTime, end: currentTime + 120, activity: `üöÄ **Deep Work** - ${subjects[(subjectIndex + 1) % 3]}`, type: 'filler', category: 'study' });
             currentTime += 120;
             finalTimeline.push({ start: currentTime, end: currentTime + 30, activity: '‚òï Break', type: 'filler', category: 'bio' });
             currentTime += 30;
          }
          
          if (bedMins > currentTime) {
            // Dinner if not happened? Assuming late evening
             if (currentTime < 1260 && bedMins > 1320) { // If it's before 9 PM
                finalTimeline.push({ start: currentTime, end: currentTime + 45, activity: 'üç≤ Dinner', type: 'filler', category: 'bio' });
                currentTime += 45;
             }
             if (bedMins > currentTime) {
                finalTimeline.push({ start: currentTime, end: bedMins, activity: 'üìñ Revision / Backlog / NCERT', type: 'filler', category: 'study' });
             }
          }
       }
    }
    
    // Rotate Subject Index only on non-coaching days to keep rotation sane
    if (!isCoaching && !isSchool) subjectIndex++;

    // --- Format Output ---
    if (isSunday) {
      // Hardcoded Sunday Plan for simplicity
       schedule.push({
        day,
        type: 'exam',
        hours: 6,
        activities: [
          '07:00 - 08:30: üåÖ Wake up & Revision',
          '09:00 - 12:00: üìù **Full Syllabus / Mock Test**',
          '12:00 - 14:00: ü•ó Lunch & Rest',
          '14:00 - 16:30: üîç **Test Analysis** (Mistake Notebook)',
          '17:00 - 20:00: üîÑ Weak Topic Revision',
          '20:00 - 21:00: üìÖ Plan Next Week'
        ]
      });
    } else {
      // Calculate total study hours
      let dailyStudy = 0;
      const formattedActivities = finalTimeline.map(b => {
        if (b.category === 'study' || b.category === 'coaching' || b.category === 'school') {
          if (b.category === 'study') dailyStudy += (b.end - b.start) / 60;
        }
        return `${formatTimeRange(b.start, b.end)}: ${b.activity}`;
      });

      schedule.push({
        day,
        type: isCoaching ? 'coaching' : (isSchool ? 'school' : 'holiday'),
        hours: Math.round(dailyStudy * 10) / 10,
        activities: formattedActivities
      });
    }
  });

  const coachingStartHour = Math.floor(coachingStartMins / 60);
  const coachingTypeStr = coachingStartHour < 12 ? "Morning Batch" : "Evening Batch";

  return {
    summary: `Optimized ${coachingTypeStr} Schedule. Prioritizes Revision on Coaching Days and Deep Work on Free Days.`,
    schedule,
    guidelines: [
      `Conflict Resolution: If School overlaps with Coaching, we prioritized Coaching (assumed Dummy School/Skip).`,
      `Coaching Revision: The slot immediately after coaching (or after dinner) is crucial.`,
      `Subject Rotation: Topics are rotated automatically on free days to ensure balanced coverage.`,
      `Consistency: Stick to the ${sleepSchedule.bed} - ${sleepSchedule.wake} sleep cycle.`
    ]
  };
};
