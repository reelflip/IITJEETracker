
import { PlanRequest, Question, TimetableConstraints, Subject, Difficulty, WeeklySchedule, DailySchedule } from "../types";
import { MOCK_QUESTION_DB } from "../constants";

// Helper to simulate "processing" time for a realistic feel
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// --- Time Helper Functions ---

const timeToMins = (time: string): number => {
  const [h, m] = time.split(':').map(Number);
  return h * 60 + m;
};

const minsToTime = (mins: number): string => {
  let h = Math.floor(mins / 60);
  const m = mins % 60;
  if (h >= 24) h -= 24;
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
};

const formatTimeRange = (startMins: number, durationMins: number): string => {
  const endMins = startMins + durationMins;
  return `${minsToTime(startMins)} - ${minsToTime(endMins)}`;
};

// -----------------------------

/**
 * Offline Study Plan Generator
 * Creates a deterministic plan based on inputs without AI.
 */
export const generateStudyPlan = async (request: PlanRequest): Promise<string> => {
  await delay(800); // Simulate "Thinking"
  const { topics, daysAvailable, hoursPerDay, focusArea } = request;

  let planMarkdown = `## üìÖ ${daysAvailable}-Day Action Plan\n`;
  planMarkdown += `**Focus:** ${focusArea} | **Daily Commitment:** ${hoursPerDay} Hours\n\n`;
  planMarkdown += `This plan is designed to optimize your preparation for JEE using spaced repetition and active recall.\n`;
  planMarkdown += `---\n\n`;

  const topicsList = [...topics];
  let topicIndex = 0;

  for (let day = 1; day <= daysAvailable; day++) {
    planMarkdown += `### Day ${day}\n`;
    
    // Assign topics cyclically
    const topicsForToday = [];
    if (topicsList.length > 0) {
      // Pick 1 primary topic
      topicsForToday.push(topicsList[topicIndex]);
      topicIndex = (topicIndex + 1) % topicsList.length;
    }
    
    const primaryTopic = topicsForToday[0] || "Revision of backlog";
    const slotDuration = Math.floor(hoursPerDay / 2);

    if (focusArea === "Theory Intensive") {
        planMarkdown += `- **Session 1 (${slotDuration}h):** üìñ **Theory Deep Dive** - ${primaryTopic}. Read NCERT and class notes. Focus on derivations.\n`;
        planMarkdown += `- **Session 2 (${hoursPerDay - slotDuration}h):** ‚úçÔ∏è **Short Notes** - Create formula sheets for ${primaryTopic} and solve basic illustrations.\n`;
    } else if (focusArea === "Problem Solving") {
        planMarkdown += `- **Session 1 (${slotDuration}h):** üß© **Guided Practice** - Solve 20-30 Mains level questions on ${primaryTopic}.\n`;
        planMarkdown += `- **Session 2 (${hoursPerDay - slotDuration}h):** üöÄ **Challenge Mode** - Attempt 10 Advanced level problems or PYQs for ${primaryTopic}.\n`;
    } else if (focusArea === "Revision & Mock Tests") {
        planMarkdown += `- **Session 1:** üìù **Topic Test** - Take a timed test on ${primaryTopic}.\n`;
        planMarkdown += `- **Session 2:** üîç **Analysis** - Analyze errors and revise weak concepts.\n`;
    } else {
        // Balanced
        planMarkdown += `- **Session 1 (${slotDuration}h):** üìñ **Concept Review** - Quick theory recap of ${primaryTopic}.\n`;
        planMarkdown += `- **Session 2 (${hoursPerDay - slotDuration}h):** ‚úèÔ∏è **Problem Practice** - Solve Exercise 1 & 2 for ${primaryTopic}.\n`;
    }
    
    planMarkdown += `\n`;
  }
  
  planMarkdown += `\n---\n*Generated by BT PrepTracker Smart Engine*`;
  return planMarkdown;
};

/**
 * Offline Question Generator
 * Fetches from a local DB or generates templated questions.
 */
export const generatePracticeQuestions = async (topicName: string, difficulty: string, subject?: Subject): Promise<Question[]> => {
  await delay(600);
  
  // Robust subject detection
  let derivedSubject = subject;
  if (!derivedSubject) {
      if (['Kinematics', 'Newton', 'Work', 'Rotation', 'Gravitation', 'Electrostatics', 'Current', 'Optics', 'Units'].some(k => topicName.includes(k))) derivedSubject = Subject.PHYSICS;
      else if (['Mole', 'Atomic', 'Bonding', 'Gaseous', 'Equilibrium', 'Organic', 'GOC', 'Isomerism', 'Block'].some(k => topicName.includes(k))) derivedSubject = Subject.CHEMISTRY;
      else derivedSubject = Subject.MATHS;
  }

  const dbQuestions = (derivedSubject ? MOCK_QUESTION_DB[derivedSubject] : []) || [];
  
  // Return mixed real + templated questions to ensure we always have 5
  const results: Question[] = [];

  // 1. Add real questions from DB if available
  dbQuestions.forEach(q => {
     if (q.questionText && q.options && q.correctAnswer && q.explanation) {
       results.push({
         ...q as Question,
         difficulty: difficulty // Override for display consistency
       });
     }
  });

  // 2. Fill remaining with templated questions
  while (results.length < 5) {
    const num = results.length + 1;
    results.push({
      questionText: `[${topicName}] Conceptual Question #${num}: Which of the following statements is true regarding this topic at a ${difficulty.split(' ')[0]} level?`,
      options: [
        `Option A: Statement regarding concept 1 of ${topicName}`,
        `Option B: Statement regarding concept 2 of ${topicName}`,
        `Option C: Statement regarding concept 3 of ${topicName}`,
        `Option D: Statement regarding concept 4 of ${topicName}`
      ],
      correctAnswer: `Option A: Statement regarding concept 1 of ${topicName}`,
      explanation: `**Analysis:**\nThis is a generated practice question. In a real exam scenario, you would analyze the specific conditions given. Since the difficulty is **${difficulty}**, ensure you check for edge cases in ${topicName}.`,
      difficulty: difficulty
    });
  }

  return results.slice(0, 5);
}

/**
 * Offline Timetable Generator
 * Returns a structured object using dynamic time calculation.
 */
export const generateWeeklyTimetable = async (constraints: TimetableConstraints): Promise<WeeklySchedule> => {
  await delay(500);
  const { coachingDays, coachingTime, schoolDetails, sleepSchedule } = constraints;
  
  const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
  const subjects = ['Physics', 'Maths', 'Chemistry']; 
  let subjectIndex = 0; 

  const schedule: DailySchedule[] = [];

  // Parse Constraints
  const wakeMins = timeToMins(sleepSchedule.wake);
  const bedMins = timeToMins(sleepSchedule.bed);
  const coachingStartMins = timeToMins(coachingTime.start);
  const coachingEndMins = timeToMins(coachingTime.end);
  const schoolStartMins = timeToMins(schoolDetails.start);
  const schoolEndMins = timeToMins(schoolDetails.end);
  
  // Determine Coaching Type
  const isMorningCoaching = coachingStartMins < 720; // Starts before 12:00 PM

  days.forEach(day => {
    const isCoaching = coachingDays.includes(day);
    const isSchool = schoolDetails.attending && day !== 'Sun';
    const isSunday = day === 'Sun';
    
    let activities: string[] = [];
    let type: DailySchedule['type'] = 'school';
    let studyHours = 0;
    let currentTime = wakeMins;

    // --- Sunday Logic ---
    if (isSunday) {
      type = 'exam';
      activities.push(`${formatTimeRange(currentTime, 60)}: üåÖ Wake up & Light Breakfast`);
      currentTime += 60;
      activities.push(`${formatTimeRange(currentTime, 60)}: üß† Formula Revision`);
      currentTime += 60;
      activities.push(`${formatTimeRange(currentTime, 180)}: üìù **Full Syllabus / Part Test** (Exam Sim)`);
      currentTime += 180;
      activities.push(`${formatTimeRange(currentTime, 90)}: ü•ó Lunch & Relax`);
      currentTime += 90;
      activities.push(`${formatTimeRange(currentTime, 150)}: üîç **Test Analysis** (Mistake Notebook)`);
      currentTime += 150;
      activities.push(`${formatTimeRange(currentTime, 30)}: ‚òï Tea Break`);
      currentTime += 30;
      activities.push(`${formatTimeRange(currentTime, 120)}: üîÑ Weak Area Revision`);
      studyHours = 6.5;
    } 
    else {
      // --- Weekday Logic ---
      
      // 1. Morning Routine
      activities.push(`${formatTimeRange(currentTime, 30)}: üåÖ Wake Up & Freshen Up`);
      currentTime += 30;

      // 2. Pre-Noon Block
      if (isMorningCoaching && isCoaching) {
         type = 'coaching';
         // Travel buffer (approx 30 mins before)
         if (currentTime < coachingStartMins - 30) {
            activities.push(`${formatTimeRange(currentTime, coachingStartMins - 30 - currentTime)}: ü•õ Breakfast & Travel`);
         }
         currentTime = coachingStartMins;
         
         // Coaching
         activities.push(`${formatTimeRange(coachingStartMins, coachingEndMins - coachingStartMins)}: üè¢ **Coaching Classes**`);
         currentTime = coachingEndMins;

         // Travel back & Lunch
         activities.push(`${formatTimeRange(currentTime, 90)}: ü•ó Travel Back, Lunch & Rest`);
         currentTime += 90;

         // Post-Coaching Revision (Critical)
         activities.push(`${formatTimeRange(currentTime, 120)}: üîÑ **Class Revision** (Physics/Chem/Maths notes)`);
         currentTime += 120;
         studyHours += 2;

      } else if (isSchool) {
         type = 'school';
         // School duration
         if (schoolStartMins > currentTime) {
            // Quick morning study if time permits
            const diff = schoolStartMins - currentTime;
            if (diff >= 60) {
               activities.push(`${formatTimeRange(currentTime, 60)}: üß† Quick Revision / Formulas`);
               studyHours += 1;
               currentTime += 60;
            }
         }
         activities.push(`${formatTimeRange(schoolStartMins, schoolEndMins - schoolStartMins)}: üè´ **School**`);
         currentTime = schoolEndMins;
         
         activities.push(`${formatTimeRange(currentTime, 60)}: ü•ó Lunch & Power Nap`);
         currentTime += 60;

      } else {
         // Dummy School / Holiday Morning
         type = 'holiday';
         const sub1 = subjects[subjectIndex % 3];
         activities.push(`${formatTimeRange(currentTime, 150)}: üöÄ **Deep Work Session 1** - ${sub1}`);
         currentTime += 150;
         studyHours += 2.5;
         
         activities.push(`${formatTimeRange(currentTime, 45)}: üç≥ Breakfast Break`);
         currentTime += 45;

         const sub2 = subjects[(subjectIndex + 1) % 3];
         activities.push(`${formatTimeRange(currentTime, 150)}: ‚úèÔ∏è **Problem Solving Session** - ${sub2}`);
         currentTime += 150;
         studyHours += 2.5;

         activities.push(`${formatTimeRange(currentTime, 60)}: ü•ó Lunch Break`);
         currentTime += 60;
      }

      // 3. Afternoon / Evening Block
      
      // If Evening Coaching
      if (!isMorningCoaching && isCoaching) {
         type = 'coaching';
         
         // Time between current and coaching start
         const timeUntilCoaching = coachingStartMins - currentTime;
         
         if (timeUntilCoaching > 60) {
            activities.push(`${formatTimeRange(currentTime, timeUntilCoaching - 30)}: üéí Homework / Pre-class Prep`);
            studyHours += (timeUntilCoaching - 30) / 60;
         }
         
         activities.push(`${formatTimeRange(coachingStartMins, coachingEndMins - coachingStartMins)}: üè¢ **Coaching Classes**`);
         currentTime = coachingEndMins;

         activities.push(`${formatTimeRange(currentTime, 45)}: üç≤ Dinner & Relax`);
         currentTime += 45;

         activities.push(`${formatTimeRange(currentTime, 90)}: üîÑ **Daily Revision** (Revise today's notes)`);
         studyHours += 1.5;
         currentTime += 90;

      } else {
         // Free Evening (Self Study)
         // Calculate remaining time until dinner/bed
         // Slot 1
         const subject = subjects[(subjectIndex + (isSchool ? 0 : 2)) % 3];
         if (!isSchool) subjectIndex++; // Rotate on dummy days

         activities.push(`${formatTimeRange(currentTime, 120)}: üöÄ **Deep Work** - ${subject}`);
         currentTime += 120;
         studyHours += 2;

         activities.push(`${formatTimeRange(currentTime, 30)}: ‚òï Tea Break / Walk`);
         currentTime += 30;

         // Slot 2
         activities.push(`${formatTimeRange(currentTime, 90)}: ‚úèÔ∏è Practice / Backlog`);
         currentTime += 90;
         studyHours += 1.5;

         activities.push(`${formatTimeRange(currentTime, 45)}: üç≤ Dinner`);
         currentTime += 45;
      }

      // 4. Night Cap
      const minsUntilBed = bedMins - currentTime;
      if (minsUntilBed > 0) {
         activities.push(`${formatTimeRange(currentTime, Math.min(minsUntilBed, 60))}: üìñ NCERT Reading / Error Log`);
         studyHours += Math.min(minsUntilBed, 60) / 60;
      }
    }

    // Round study hours for neatness
    studyHours = Math.round(studyHours * 10) / 10;

    schedule.push({
      day,
      activities,
      type,
      hours: studyHours
    });
  });

  const coachingTypeStr = isMorningCoaching ? "Morning Batch" : "Evening Batch";

  return {
    summary: `Custom Schedule for ${coachingTypeStr}. Optimized for ${studyHoursPerWeek(schedule)} hours of self-study this week.`,
    schedule,
    guidelines: [
      `Consistency: Your sleep schedule (${sleepSchedule.bed} - ${sleepSchedule.wake}) determines your focus. Stick to it.`,
      `Coaching Days: The 2-hour post-class revision slot is the most important part of your day.`,
      `Breaks: The schedule includes gaps. Use them to move around, not to scroll social media.`,
      `Subject Rotation: Physics, Chemistry, and Maths are rotated on free days to prevent burnout.`
    ]
  };
};

const studyHoursPerWeek = (schedule: DailySchedule[]) => {
  return Math.round(schedule.reduce((acc, curr) => acc + curr.hours, 0));
};
